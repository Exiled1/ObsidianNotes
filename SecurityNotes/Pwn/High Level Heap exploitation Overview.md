#YJ

## High level heap exploitation overview

## YJ Recommendations
1) understand how glibc heap work in general, by reading the blog post
2) play with how2heap for first few ones
3) take a look at the challenge, and identify which kind of type it is; you may read some writeup about that (not till the end to the solution)
4) try to apply what you learn from how2heap to the exploitation generally, heap exploits requiring code execution often require one to construct
---
1. information leak, either sequential on the heap or arbitrary; if you have info leak vuln in stack or others, you do not need one.
2. either sequential or arbitrary write; sequential write can work as changing vTable or function pointers in adjacent object, or arbitrary write can work as overwriting any pointers.

## Attack Prerequisites
So the attack will be very similar to that of using format string vulnerability after you construct how you can apply arbitrary read or write.

So it's mostly about manipulating heap objects to gain capability of arbitrary read/write and another basics of C/C++-temporal safety is that heap overflow can manipulate metadata, and doing such affect the following:
> 1) malloc(); it will use metadata to search a free object that can be allocated. This may return arbitrary address, e.g., GOT table, etc.
> 2) free(); there could be a case that you can a) free a legitimate object but with malicious metadata, resulting in having a controlled state for the attacker;
		a)  free on a weird address, e.g., stack or non-heap object pointers (e.g., not at the address starting of the heap object, pointing in the middle, etc.). 
		b) case b is called invalid-free, and that can put arbitrary address (e.g., fabricate a fake heap object/metadata structure on the stack; also overflow the heap to honor such metadata; and then, fool the program to free (manipulated_stack_address)

Then you can put that address as GOT table address, then it will be put on a free object list (because it is free-ed) then next malloc() can return the GOT address.

c) free on an already free-ed object; this is called double-free()

Case of c would be similar to case b (in regards to manipulate heap metadata to allow double free, similar to making heap metadata honors invalid metadata on the stack). After freeing the object twice, the metadata will be corrupted for having two same heap object address in the metadata;

This may allow 2 subsequent malloc() call to return the same address

Then suppose the program first allocates an object sized 120 

The program asks your name length, and run malloc(length)

You type 120 for the length

Then both the object and the name would have the **same address** after double-free happens

So writing on name will overwrite all the data in the object, so we can replace vTable, or any function pointers, etc.

Long story short, it is all about fooling glibc malloc/free to return weird address to create a condition that we can overwrite some meaningful data

e.g., vTable pointers, GOT, return address, function pointer in object, or any data in the object that can make you as admin, etc.

## Attack example
1) You fool the glibc malloc to return a stack pointer in your 3rd malloc call with size 20. Then, you can fool it to return any of `return_address_minus_12_or_less` and make your program to use that object for any of user-input; then you can change the retaddr.

## Difficulties of Heap Overflow
- Heap overflow $\rightarrow$ creating that itself requires playing with C/C++ temporal safety primitives and fool the glibc malloc()/free() mechanism to achieve sequential/arbitrary read/write
- 